import copy
import csv
import math
import datetime
import argparse
import numpy as np
import matplotlib.pyplot as plt
import os
from PIL import Image
from tqdm import tqdm


def smallest_x(elem):
    return int(elem.split(",")[0])


def composite_images(image_path, composite_x, composite_y, filename):
    """ Generates full image of different tiles with corresponding coordinates

    :param image_path: string, project name / original tiffs name
    :param composite_x: int, width of original tiff
    :param composite_y: int, length of original tiff
    :param filename: string, desired images to compose (e.g. pseudochannel-1.png)
    :return: void
    """

    composite = Image.new('RGB', (composite_x, composite_y))  # composite image
    offset_x = 0
    offset_y = 0

    tiles_original = sorted(os.listdir(image_path), key=smallest_x)
    tiles = copy.deepcopy(tiles_original)

    for i in range(len(tiles)):
        tiles[i] = tiles[i].split(",")
        tiles[i] = [int(tiles[i][0]) - 5012, int(tiles[i][1]) - 26886]
        if i > 0:
            offset_y = int(tiles[i][1])
            offset_x = int(tiles[i][0])
        tiles[i] = [tiles[i][0] + offset_x, tiles[i][1] + offset_y]

    i = 0
    for tile in tiles_original:  # iterate over all tiles in project (e.g. "454,213")
        tile = tile.split(",")

        for file in os.listdir(image_path + str(tile[0]) + "," + str(tile[1])):  # iterate over files in tile folder
            if file == filename:  # only composing images of same type
                tile_im = Image.open(image_path + str(tile[0]) + "," + str(tile[1]) + "/" + file)

                composite.paste(tile_im, tuple(tiles[i]))  # tuple(int(cord) for cord in offset))  # pasting into composite, cord is tiles
                # upper left corner coordinates (x or y) in the full composite
        i += 1

    composite.save(filename.replace(".png", "_composite.png"))


def read_halo(csv_path):
    """ Read csv files generated by Halo

    param csv_path: string, path to csv file containing HALO cells
    :return: dictionary, keys are markers and values containing cells coordinates
    """
    coordinates = {"CD20": [], "CD3": []}

    with open(csv_path) as csv_file:
        csv_reader = csv.reader(csv_file)
        line_count = 0

        for row in csv_reader:
            if line_count == 0:
                # exclude header
                line_count += 1
            else:
                line_count += 1

                cell_coordinates = [((int(row[1]) + int(row[2])) / 2), ((int(row[3]) + int(row[4])) / 2)]

                if row[9] == "1":
                    # CD20
                    cell_coordinates.append(float(row[12]))
                    coordinates["CD20"].append(cell_coordinates)
                elif row[13] == "1":
                    # CD3
                    cell_coordinates.append(float(row[18]))
                    coordinates["CD3"].append(cell_coordinates)

    return coordinates


def read_halo_tile(csv_path, tile_x, tile_y, tile_size_x, tile_size_y):
    """ Reads certain cells out of csv files generated by Halo

    param csv_path: string, path to csv file containing HALO cells
    :return: dictionary, keys are markers and values containing cells coordinates
    """
    coordinates = {"CD20": [], "CD3": []}

    with open(csv_path) as csv_file:
        csv_reader = csv.reader(csv_file)
        line_count = 0

        for row in csv_reader:
            if line_count == 0:
                # exclude header
                line_count += 1
            else:
                line_count += 1

                if tile_x <= ((int(row[1]) + int(row[2])) / 2) < tile_x + tile_size_x and tile_y <= ((int(row[3]) + int(row[4])) / 2) < tile_y + tile_size_y:

                    cell_coordinates = [((int(row[1]) + int(row[2])) / 2), ((int(row[3]) + int(row[4])) / 2)]

                    if row[9] == "1":
                        # CD20
                        cell_coordinates.append(float(row[12]))
                        coordinates["CD20"].append(cell_coordinates)
                    elif row[13] == "1":
                        # CD3
                        cell_coordinates.append(float(row[18]))
                        coordinates["CD3"].append(cell_coordinates)

    return coordinates


def read_immunet_tile(file_path, tile_x, tile_y, tile_size_x, tile_size_y):
    """ Read txt file generated by immunet

    :param file_path: string, path to txt file containing immunet cells
    :return: dictionary, keys are markers and values containing cells coordinates
    """
    coordinates = {"CD20": [], "CD3": []}

    with open(file_path) as f:
        lines = f.readlines()
        for row in lines:
            row = row.split()

            if not row:
                continue

            if tile_x <= (int(row[1])) < tile_x + tile_size_x and tile_y <= int(row[0]) < tile_y + tile_size_y:

                if float(row[2]) > 0 and float(row[3]) < float(row[2]) / 10:
                    # CD3
                    cell_coordinates = [int(row[1]), int(row[0]), float(row[2])]
                    coordinates["CD3"].append(cell_coordinates)
                elif float(row[2]) < float(row[3]) / 10 and float(row[3]) > 0:
                    # CD20
                    cell_coordinates = [int(row[1]), int(row[0]), float(row[3])]
                    coordinates["CD20"].append(cell_coordinates)

    return coordinates


def read_immunet(file_path):
    """ Read txt file generated by immunet

    :param file_path: string, path to txt file containing immunet cells
    :return: dictionary, keys are markers and values containing cells coordinates
    """
    coordinates = {"CD20": [], "CD3": []}

    with open(file_path) as f:
        lines = f.readlines()
        for row in lines:
            if not row or row.startswith("tile:"):
                continue

            row = row.split()

            if float(row[2]) > 0 and float(row[3]) < float(row[2]) / 10:
                # CD3
                cell_coordinates = [int(row[1]), int(row[0]), float(row[2])]
                coordinates["CD3"].append(cell_coordinates)
            elif float(row[2]) < float(row[3]) / 10 and float(row[3]) > 0:
                # CD20
                cell_coordinates = [int(row[1]), int(row[0]), float(row[3])]
                coordinates["CD20"].append(cell_coordinates)

    return coordinates


def min_distance_cells(halo_cord, immunet_cord, marker):
    """ Matching cell to cell by different tools

    :param halo_cord: dictionary, coordinates from halo csv file
    :param immunet_cord: dictionary, coordinates from immunet text file
    :param marker: string, key for dictionaries (marker)
    :return: void
    """

    for h_cord in tqdm(halo_cord[marker]):
        distances = np.array([])  # array of all distances from one halo cell to all immunet cells

        cells_in_rad = list((i_cord for i_cord in immunet_cord[marker] if radius(h_cord[0], i_cord[0]) and radius(h_cord[1], i_cord[1])))

        if not cells_in_rad:
            continue

        for i_cord in cells_in_rad:
            # euclidian distance to each cell calculated
            dist = math.sqrt(pow(h_cord[0] - i_cord[0], 2) + pow(h_cord[1] - i_cord[1], 2))
            distances = np.append(distances, dist)

        min_distance_index = distances.argmin()  # index of the smallest distance / index of cell
        min_distance = distances[min_distance_index]  # value of the smallest distance

        # cells only corresponding, if the difference is smaller than 10px
        if min_distance < 10:
            # argmin gives index of minimum distance -> index corresponds to cell in immunet_cord
            h_cord.append(min_distance_index)
            h_cord.append(min_distance)


def radius(h_cord, i_cord):
    for i in range(-10, 10):
        if int(h_cord) + i == int(i_cord):

            return True


def plot_matches(halo_cord, immunet_cord, path):
    """ Plotting all matched and unmatched cells in bar graph for each Halo and immunet

    :param halo_cord: dictionary, keys are markers and values cell coordinates
    :param immunet_cord: dictionary, keys are markers and values cell coordinates
    :return: void
    """
    keys = list(halo_cord.keys())  # list of markers
    labels = ["HALO", "ImmuNet"]
    cells_halo, cells_immunet, unmatched_halo = 0, 0, 0  # amount of cells in Halo and Immunet, amount of unmatched
    # cells in Halo

    for marker in keys:
        cells_halo += len(halo_cord[marker])
        unmatched_halo += len([cell for cell in halo_cord[marker] if len(cell) == 3])
        cells_immunet += len(immunet_cord[marker])

    matched_halo = cells_halo - unmatched_halo  # amount of matched cells in Halo

    unmatched_cells = [unmatched_halo, (cells_immunet - matched_halo)]
    matched_cells = [matched_halo, matched_halo]

    width = 0.35  # the width of the bars

    fig, ax = plt.subplots()

    ax.bar(labels, matched_cells, width, label='matched')
    ax.bar(labels, unmatched_cells, width, bottom=matched_cells,
           label='unmatched')

    ax.set_ylabel('amount cells')
    ax.set_title('tool')
    ax.legend()

    plt.savefig(path + "matched_cells.png", dpi=fig.dpi)


def plot_cells(halo_cord, immunet_cord, marker, path):
    """ Plotting all matched cells

    :param halo_cord: dictionary, keys are markers and values cell coordinates
    :param immunet_cord: dictionary, keys are markers and values cell coordinates
    :param marker: string, key for dictionaries (marker)
    :return: void
    """
    halo_cord = [cell for cell in halo_cord[marker] if len(cell) > 3]  # all halo coordinates with matches
    indexes_corr_cells = np.array([cell[3] for cell in halo_cord])  # extraction of corresponding immunet indexes
    immunet_cord = [immunet_cord[marker][i] for i in indexes_corr_cells]  # all immunet coordinates with matches

    h_x = np.array([x[0] for x in halo_cord])  # array of all x coords in Halo
    h_y = np.array([y[1] for y in halo_cord])  # array of all y coords in Halo
    i_x = np.array([x[0] for x in immunet_cord])  # array of all x coords in immunet
    i_y = np.array([y[1] for y in immunet_cord])  # array of all y coords in immunet

    print(h_x)
    print(h_y)
    print(i_x)
    print(i_y)

    fig = plt.figure()

    plt.xlim([0, 60])
    plt.ylim([0, 60])

    plt.scatter(h_x, h_y, marker="+", color="lightblue", label="HALO")
    plt.scatter(i_x, i_y, marker="+", color="y", label="ImmuNet")

    plt.legend()

    plt.savefig(path + marker + "_cells.png", dpi=fig.dpi)


def plot_intensities(halo_cord, immunet_cord, path):
    """ Plotting intensities of the cells

    :param halo_cord: dictionary, keys are markers and values cell coordinates
    :param immunet_cord: dictionary, keys are markers and values cell coordinates
    :return: void
    """
    halo_cord_3 = halo_cord["CD3"]
    immunet_cord_3 = immunet_cord["CD3"]

    halo_cord_20 = halo_cord["CD20"]
    immunet_cord_20 = immunet_cord["CD20"]

    intensity_y_3 = np.array([cell[2] for cell in halo_cord_3 if len(cell) > 3])  # excluding unmatched cells
    indexes_x_3 = np.array([cell[3] for cell in halo_cord_3 if len(cell) > 3])
    intensity_x_3 = np.array([immunet_cord_3[i][2] for i in indexes_x_3])

    intensity_y_20 = np.array([cell[2] for cell in halo_cord_20 if len(cell) > 3])
    indexes_x_20 = np.array([cell[3] for cell in halo_cord_20 if len(cell) > 3])
    intensity_x_20 = np.array([immunet_cord_20[i][2] for i in indexes_x_20])

    line = np.array([0, 1])

    fig = plt.figure()

    plt.scatter(intensity_x_3, intensity_y_3, marker="o", color="limegreen")
    plt.scatter(intensity_x_20, intensity_y_20, marker="o", color="r")

    plt.plot(line, linestyle="dotted", color="lightgrey")

    plt.xlim([0, 1])
    plt.ylim([0, 1])
    plt.savefig(path + "intensities.png", dpi=fig.dpi)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--function', type=str, default="plot", required=False,
                        help="type 'plot' for plotting graphics\n"
                             "type 'comp_img' for generating a composite image (image type needed)\n")
    parser.add_argument('--img_type', type=str, default="cell-center-distance-prediction.png", required=False,
                        help="type 'cell-center-distance-prediction.png' for composing a whole image\n"
                             "type 'pseudochannel-0.png' for composing a whole image from CD3\n"
                             "type 'pseudochannel-1.png' for composing a whole image from CD20\n")
    parser.add_argument('--x_composite', type=int, default=42004, required=False,
                        help="type width of original tiff\n")
    parser.add_argument('--y_composite', type=int, default=47909, required=False,
                        help="type height of original tiff\n")
    parser.add_argument('--path', type=str, default="immunet_modified_pipeline/demo-output/output_tilecache_data2_cluster/output_data2/HALO-N2125_11/", required=False,
                        help="type path for projects output data\n")
    parser.add_argument('--halo_project', type=str, default="N2125-14-1.csv", required=False,
                        help="type files name for HALO projects csv file \n")

    args = parser.parse_args()

    function_type = args.function
    image_type = args.img_type
    path = args.path
    x_composite = args.x_composite
    y_composite = args.y_composite
    halo_project = args.halo_project

    if function_type == "comp_img":
        composite_images(path, x_composite, y_composite, image_type)

    elif function_type == "plot":
        halo_cord = read_halo(halo_project)
        immunet_cord = read_immunet("prediction.txt")
        print('Finished reading', datetime.datetime.now())
        min_distance_cells(halo_cord, immunet_cord, "CD20")
        min_distance_cells(halo_cord, immunet_cord, "CD3")
        print('Finished distance calculation', datetime.datetime.now())

        plot_matches(halo_cord, immunet_cord, path)
        print('Plotted matches', datetime.datetime.now())

        plot_cells(halo_cord, immunet_cord, "CD20", path)
        print('Plotted CD20 cells', datetime.datetime.now())

        plot_cells(halo_cord, immunet_cord, "CD3", path)
        print('Plotted CD3 cells', datetime.datetime.now())

        plot_intensities(halo_cord, immunet_cord, path)
        print('Plotted intensities', datetime.datetime.now())
